#!/usr/bin/python3
#
# ~/dev/py/dvcz/dvc_commit

"""
Create a project BuildList and post project files to the committer's
subdirectory of in/ in DVCZ's content-keyed store.

If we are not in a project directory (one with a .dvcz/ subdirectory) we
search upward to find one and then make that our working directory.
"""

import os
import sys
from argparse import ArgumentParser

from buildlist import(BuildList,
                      check_dirs_in_path, generate_rsa_key, rm_f_dir_contents)
from optionz import dump_options
from xlattice import (check_using_sha, parse_using_sha, fix_using_sha)
from xlattice.util import get_exclusions, timestamp_now
from dvcz import(__version__, __version_date__, dvc_get_project_info)


def doit(options):
    """
    Given the command-line options, create the BuildList.

    Serialize the BuildList, append its hash to a log, and populate
    the content-keyed store using the selected SHA hash type.

    """
    parent_path = options.parent_path
    dest_dvcz_path = options.dest_dvcz_path
    excl = options.excl
    key_path = options.key_path
    list_file = options.list_file
    proj_name = options.proj_name
    u_path = options.u_path      # if None, don't save to u_path
    using_sha = options.using_sha

    blist = BuildList.list_gen(proj_name, parent_path, dest_dvcz_path,
                               list_file, key_path, excl, True,  # logging=True
                               u_path, using_sha)

    print("BuildList written to %s" % os.path.join(dest_dvcz_path, list_file))

    # confirm that whatever is in the BuildList is now in u_path
    if u_path:
        unmatched = blist.tree.check_in_u_dir(u_path)
        if unmatched:
            for unm in unmatched:
                print("NOT IN UDIR: ", unm)


def get_args():
    """ Collect command-line arguments. """

    now = timestamp_now()
    app_name = 'dvc_commit %s' % __version__

    # parse the command line ----------------------------------------

    desc = 'generate build list for directory, optionally populating u_path'
    parser = ArgumentParser(description=desc)

    parser.add_argument('-j', '--just_show', action='store_true',
                        help='show options and exit')

    # NOT CURRENTLY SUPPORTED (may never be)
    parser.add_argument('-M', '--match_pat', action='append',
                        help='include only files matching this pattern')

    parser.add_argument('-p', '--proj_path', default=os.getcwd(),
                        help='data directory for build list (default=../)')

    parser.add_argument('-T', '--testing', action='store_true',
                        help='this is a test run')

    parser.add_argument('-V', '--showVersion', action='store_true',
                        help='display version number and exit')

    # -1,-2,-3, using_sha, -v/--verbose
    parse_using_sha(parser)

    parser.add_argument(
        '-X', '--exclusions', action='append',
        help='do not include files/directories matching this pattern')

    args = parser.parse_args()

    if args.showVersion:
        print(app_name)
        sys.exit(0)

    args.app_name = app_name
    args.now = now
    return parser, args


def check_sanity(parser, args):
    """ check for options that just don't make sense. """

    if not args.just_show:
        check_using_sha(args.using_sha)

        if (not args.proj_path) or (args.proj_path == ''):
            print("no data directory specified")
            parser.print_usage()
            sys.exit(1)

        if not os.path.isdir(args.proj_path):
            print("data directory '%s' isn't a directory" % args.proj_path)
            parser.print_usage()        # short form
            # parser.print_help()       # long form (what you get from -h)
            sys.exit(1)

        if args.testing:
            args.key_path = os.path.join(
                'tmp', args.path.join(
                    'home', args.path.join('node', 'skPriv.pem')))

        else:
            args.key_path = os.path.join(
                os.environ['HOME'],
                args.path.join('node', 'skPriv.pem'))

        if not os.path.exists(args.key_path):
            check_dirs_in_path(args.key_path)
            if args.testing:
                generate_rsa_key(args.key_path, 1024)
            else:
                generate_rsa_key(args.key_path, 2048)


def add_derived(parser, args):
    """
    Wired-in paths.

    Arrive here with args.proj_path known and known to be a directory.
    """

    proj_path = args.proj_path

    # Determine the path to .dvcz -----------------------------------
    dvcz_path = os.path.abspath(os.path.join(proj_path, '.dvcz'))

    # If necessary search upward for a .dvcz directory; if it's
    # $HOME/.dvcz or /.dvcz, complain and take an error exit

    # At this point we have a path to .dvcz
    args.dvcz_path = dvcz_path

    # Get the project's version number ------------------------------
    proj_version_path = os.path.join(dvcz_path, 'version')
    if not os.path.exists(proj_version_path):
        print("%s does not exist -- cannot continue" % proj_version_path)
        sys.exit(1)
    with open(proj_version_path, 'r') as file:
        proj_version = file.read()

    # Extract the project name and  from that the BuildList's title -

    # we calculate the project name from dvcz_path
    proj_path_parts = dvcz_path.split('/')
    args.proj_name = proj_path_parts[-2]
    args.parent_path = '/'.join(proj_path_parts[:-2])
    # DEBUG
    print("DVCZ_PATH:    %s" % dvcz_path)
    print("PARTS:        %s" % str(proj_path_parts))
    print("PROJ_NAME:    %s" % args.proj_name)
    print("PARENT_PATH:  %s" % args.parent_path)
    print("PROJ VERSION: %s" % proj_version)
    # END
    args.title = '%s_%s' % (args.proj_name, proj_version)
    # DEBUG
    print("TITLE:        %s" % args.title)
    # END

    # Other things in .dvcz: ----------------------------------------
    args.ignore_file = os.path.join(proj_path, '.dvczignore')
    args.list_file = os.path.join(dvcz_path, 'lastBuildList')

    # And things elsewhere ------------------------------------------
    args.key_path = os.path.join(
        os.environ['HOME'], os.path.join(
            '.dvcz', os.path.join('node', 'skPriv.pem')))


def check_args(parser, args):
    """ Check and possibly edit command-line arguments. """

    add_derived(parser, args)
    fix_using_sha(args)

    args.cur_dir = os.getcwd()
    if os.path.exists(args.ignore_file):
        args.excl = get_exclusions(args.cur_dir)
    else:
        print("WARNING: ignore file '%s' NOT FOUND" % args.ignore_file)
        args.excl = []
    if not 'build' in args.excl:
        args.excl.append('build')

    if args.exclusions:
        args.excl.extend(args.exclusions)

    if args.testing:
        args.dvcz_path = os.path.join('tmp/dvcz')
        if os.path.exists(args.dvcz_path):
            rm_f_dir_contents(args.dvcz_path)      # empties the directory
    os.makedirs(args.dvcz_path, 0o755, exist_ok=True)

    check_sanity(parser, args)

    # u_path ------------------------------------------------
    if args.testing and args.u_path:
        if args.u_path[0] == '/':
            args.u_path = args.u_path[1:]
        args.u_path = os.path.join('tmp', args.u_path)
        if os.path.exists(args.u_path):
            rm_f_dir_contents(args.u_path)

    if args.u_path:
        os.makedirs(args.u_path, 0o755, exist_ok=True)

    # committer and in_path -------------------------------

    # The directory at u_path is known to exist.  We are committing to
    # a committer-specific subdirectory, u_path/in/ID, where ID is a
    # 40- or 64-char hex value, the committer's ID.

    # title -----------------------------------------------
    if not args.title:
        args.title = "%s_v%s" % (args.project, __version__)


def show_args(args):
    """
    Conditionally display sorted option names and values.

    Where the option value is list, display the value separately
    under the capitalized option name.
    """
    if args.verbose or args.just_show:
        print("%s %s\n" % (args.app_name, __version_date__))

    if args.verbose or args.just_show:
        print(dump_options(args))

    if args.just_show:
        sys.exit(0)


def main():
    """
    Collect comamnd line options and execute the command if required.
    """

    parser, args = get_args()
    dvc_get_project_info(args)      # and possibly change working directory
    check_args(parser, args)
    show_args(args)

    # do what's required --------------------------------------------

    # try: ACQUIRE LOCK ON PROJECT, that is, on the name of the project
    doit(args)

    # finally: RELEASE LOCK ON PROJECT

if __name__ == '__main__':
    main()
